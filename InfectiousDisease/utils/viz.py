import numpy as npfrom itertools import combinationsfrom sklearn.metrics import r2_scoreimport matplotlib.pyplot as pltimport seaborn as snsfrom matplotlib.ticker import FormatStrFormatterfrom data.data_filtering import sanity_checksdef plot_true_est_scatter(model, X_test, theta_test, n_samples, param_names,                          figsize=(20, 4), theta_approx_means=None, show=True, filename=None, font_size=12):    """    Plots a scatter plot with abline of the estimated posterior means vs true values.    :param model:    :param X_test:    :param theta_test:    :param n_samples:    :param param_names:    :param figsize:    :param theta_approx_means:    :param show:    :param filename:    :param font_size:    :return:    """    # Plot settings    plt.rcParams['font.size'] = font_size    # Convert true parameters to numpy    # theta_test = theta_test.numpy()    # Determine figure layout    if len(param_names) >= 6:        n_col = int(np.ceil(len(param_names) / 2))        n_row = 2    else:        n_col = int(len(param_names))        n_row = 1    # Initialize figure    f, axarr = plt.subplots(n_row, n_col, figsize=figsize)    if n_row > 1:        axarr = axarr.flat    # Initialize posterior means matrix, if none specified    if theta_approx_means is None:        theta_approx_means = model.sample(X_test, n_samples, to_numpy=True).mean(axis=0)    # --- Plot true vs estimated posterior means on a single row --- #    for j in range(len(param_names)):        # Plot analytic vs estimated        axarr[j].scatter(theta_approx_means[:, j], theta_test[:, j], color='black', alpha=0.4)        # get axis limits and set equal x and y limits        lower_lim = min(axarr[j].get_xlim()[0], axarr[j].get_ylim()[0])        upper_lim = max(axarr[j].get_xlim()[1], axarr[j].get_ylim()[1])        axarr[j].set_xlim((lower_lim, upper_lim))        axarr[j].set_ylim((lower_lim, upper_lim))        axarr[j].plot(axarr[j].get_xlim(), axarr[j].get_xlim(), '--', color='black')        # Compute NRMSE        rmse = np.sqrt(np.mean((theta_approx_means[:, j] - theta_test[:, j]) ** 2))        nrmse = rmse / (theta_test[:, j].max() - theta_test[:, j].min())        axarr[j].text(0.1, 0.9, 'NRMSE={:.3f}'.format(nrmse),                      horizontalalignment='left',                      verticalalignment='center',                      transform=axarr[j].transAxes,                      size=10)        # Compute R2        r2 = r2_score(theta_test[:, j], theta_approx_means[:, j])        axarr[j].text(0.1, 0.8, '$R^2$={:.3f}'.format(r2),                      horizontalalignment='left',                      verticalalignment='center',                      transform=axarr[j].transAxes,                      size=10)        # Label plot x-axis        axarr[j].set_xlabel('Estimated')        if j == 0:            # Label plot            axarr[j].set_ylabel('True')        axarr[j].set_title(param_names[j])        axarr[j].spines['right'].set_visible(False)        axarr[j].spines['top'].set_visible(False)    # Adjust spaces    f.tight_layout()    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_scatter.png".format(filename, X_test.shape[1]), dpi=600)def plot_true_est_posterior(model, n_samples, param_names, n_test=None, data_generator=None,                            X_test=None, theta_test=None, figsize=(15, 20), tight=True,                            show=True, filename=None, font_size=12):    """    Plots approximate posteriors.    """    # Plot settings    plt.rcParams['font.size'] = font_size    if data_generator is None and n_test is None:        n_test = int(X_test.shape[0])    # If time series are not provided, then generate the data    elif X_test is None and theta_test is None:        batch = data_generator(batch_size=n_test)        x_test, theta_test = sanity_checks(batch['x'], batch['theta'])        # Reshape x        x_test = x_test.reshape(x_test.shape[0], -1)    else:        raise ValueError('Either data_generator and n_test or X_test and y_test should be provided')    # Convert theta to numpy    # theta_test = theta_test.numpy()    # Initialize f    f, axarr = plt.subplots(n_test, len(param_names), figsize=figsize)    theta_samples = model.sample(X_test, n_samples, to_numpy=True)    theta_samples_means = theta_samples.mean(axis=0)    # For each row    for i in range(n_test):        for j in range(len(param_names)):            # Plot approximate posterior            sns.distplot(theta_samples[:, i, j], kde=True, hist=True, ax=axarr[i, j],                         label='Estimated posterior', color='#5c92e8')            # Plot lines for approximate mean, analytic mean and true data-generating value            axarr[i, j].axvline(theta_samples_means[i, j], color='#5c92e8', label='Estimated mean')            axarr[i, j].axvline(theta_test[i, j], color='#e55e5e', label='True')            axarr[i, j].spines['right'].set_visible(False)            axarr[i, j].spines['top'].set_visible(False)            axarr[i, j].xaxis.set_major_formatter(FormatStrFormatter('%.2f'))            axarr[i, j].get_yaxis().set_ticks([])            # Set title of first row            if i == 0:                axarr[i, j].set_title(param_names[j])            if i == 0 and j == 0:                f.legend(loc='lower center', bbox_to_anchor=(0.5, -0.03), shadow=True, ncol=3, fontsize=10,                         borderaxespad=1)                # axarr[i, j].legend(fontsize=10)    if tight:        f.tight_layout()    f.subplots_adjust(bottom=0.12)    # Show, if specified    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_density.png".format(filename, X_test.shape[1]), dpi=600, bbox_inches='tight')def plot_correlation_parameters(parameters, parameter_names, figsize=(20, 10), show=True, font_size=11):    """    :param parameters:    :param parameter_names:    :param figsize:    :param show:    :param filename:    :param font_size:    :return:    """    # Plot settings    plt.rcParams['font.size'] = font_size    # Get all possible combinations between parameters    comp_list = list(combinations(np.arange(parameters.shape[1]), 2))    # List of comp_params    comp_params = []    comp_param_names = []    for (i, j) in comp_list:        comp_params.append(np.column_stack((parameters[:, i], parameters[:, j])))        comp_param_names.append([parameter_names[i], parameter_names[j]])    # print(comp_params[0].shape)    fig, ax = plt.subplots(2, 5, figsize=figsize)    for idx in range(int(len(comp_list) / 2)):        ax[0, idx].scatter(comp_params[idx][:, 0], comp_params[idx][:, 1], color='black', alpha=0.4)        ax[0, idx].set_xlabel(comp_param_names[idx][0], fontsize=15)        ax[0, idx].set_ylabel(comp_param_names[idx][1], fontsize=15)        ax[1, idx].scatter(comp_params[5 + idx][:, 0], comp_params[5 + idx][:, 1], color='black', alpha=0.4)        ax[1, idx].set_xlabel(comp_param_names[idx + 5][0], fontsize=15)        ax[1, idx].set_ylabel(comp_param_names[idx + 5][1], fontsize=15)    # lower_lim = min(plt.xlim()[0], plt.ylim()[0])    # upper_lim = max(plt.xlim()[1], plt.ylim()[1])    # plt.xlim((lower_lim, upper_lim))    # plt.ylim((lower_lim, upper_lim))    # plt.plot(plt.xlim(), plt.ylim(), '--', color='black')    # Label plot    # plt.xlabel(parameter_names[0])    # plt.ylabel(parameter_names[1])    fig.suptitle('Parameter correlation', fontsize=20)    # Adjust spaces    plt.tight_layout()    if show:        plt.figure(figsize=figsize)        plt.show()def plot_comp_post_prior(model, n_samples, param_names, n_test=None, data_generator=None,                         X_test=None, theta_test=None, figsize=(15, 20), tight=True,                         show=True, filename=None, font_size=12):    """    :param model:    :param n_samples:    :param param_names:    :param n_test:    :param data_generator:    :param X_test:    :param theta_test:    :param figsize:    :param tight:    :param show:    :param filename:    :param font_size:    :return:    """    # Plot settings    plt.rcParams['font.size'] = font_size    if data_generator is None and n_test is None:        n_test = int(X_test.shape[0])    elif X_test is None and theta_test is None:        batch = data_generator(batch_size=n_test)        x_test, theta_test = sanity_checks(batch['x'], batch['theta'])        # Reshape x        x_test = x_test.reshape(x_test.shape[0], -1)    else:        raise ValueError('Either data_generator and n_test or X_test and y_test should be provided')        # Convert theta to numpy    # theta_test = theta_test.numpy()    # Initialize f    f, axarr = plt.subplots(n_test, len(param_names), figsize=figsize)    theta_samples = model.sample(X_test, n_samples, to_numpy=True)    theta_samples_means = theta_samples.mean(axis=0)    # For each row    for i in range(n_test):        for j in range(len(param_names)):            for k in [theta_samples[:, i, j], theta_test[i, j]]:                sns.distplot(k, kde=False, hist=True, ax=axarr[i, j],                             label=['Estimated posterior', 'Prior'])            # Plot prior distribution            # sns.distplot(theta_test[i, j], kde=False, hist=True, ax=axarr[i, j], label='Prior', color='#3d719a')            # Plot approximate posterior            # sns.distplot(theta_samples[:, i, j], kde=False, hist=True, ax=axarr[i, j], label='Estimated posterior',            #              color='#5c92e8')            # Plot lines for approximate mean, analytic mean and true data-generating value            axarr[i, j].axvline(theta_samples_means[i, j], color='#5c92e8', label='Estimated mean')            axarr[i, j].axvline(theta_test[i, j], color='#e55e5e', label='True')            axarr[i, j].spines['right'].set_visible(False)            axarr[i, j].spines['top'].set_visible(False)            axarr[i, j].xaxis.set_major_formatter(FormatStrFormatter('%.2f'))            axarr[i, j].get_yaxis().set_ticks([])            # Set title of first row            if i == 0:                axarr[i, j].set_title(param_names[j])            if i == 0 and j == 0:                f.legend(loc='lower center', bbox_to_anchor=(0.5, -0.03), shadow=True, ncol=3, fontsize=10,                         borderaxespad=1)                # axarr[i, j].legend(fontsize=10)    if tight:        f.tight_layout()    f.subplots_adjust(bottom=0.12)    # Show, if specified    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_density.png".format(filename, X_test.shape[1]), dpi=600, bbox_inches='tight')def plot_ppc(x, ts, labels, x_test=None, ps=False, cmedian=None, figsize=(10, 10), font_size=11):    # ToDo: Fix bug with shift    """    Plot predictive posterior comparison    :param x:    :param ts: ndarray of shape (n_samples, n_steps, 5)    :param labels: list of length 5        List with name of compartments    :param cmean: color    :param cmedian: color    :param ci: colormap    :param figsize: tuple    :param font_size: int, default=18        Font size    :return:    """    plt.rcParams['font.size'] = font_size    # Calculate stats    if ps is True:        # Confidence intervals        ci = [50, 90, 95]        # Percentiles for the ci        perc = [50, 10, 5]        alphas = [0.1, 0.2, 0.3]        dperc = np.asarray(perc) / 2  # [25, 5, 2.5]        uperc = 50 + dperc        lperc = 50 - dperc        up = np.percentile(ts, q=uperc, axis=0)  # (3, 100, 5)        lp = np.percentile(ts, q=lperc, axis=0)  # (3, 100, 5)        print(up[0, 50:55, 3])        print(lp[0, 50:55, 3])    if cmedian is not None:        ts_median = np.median(ts, axis=0)        print(ts_median[50:55, 3])    # Plot    # fig, ax = plt.subplots(1, 5, figsize=figsize)    # Iterate through all compartments    # for i in range(5):    #     if ci is not None:    #         for j in range(dci.shape[0]):    #             ax[i].fill_between(x, up[j, :, i], lp[j, :, i],    #                                alpha=0.5, color=colormap(j / dci.shape[0]), label='{}% ci'.format(ci[j]))    #    #     if cmedian is not None:    #         ax[i].plot(x, ts_median[:, i], color=cmedian, label='Posterior predictive median')    #    #     if x_test is not None:    #         ax[i].plot(x, x_test[:, i], linestyle='--', color='black')    #    #     ax[i].set_title(labels[i])    #     ax[i].legend(loc=1, prop={'size': 7})    fig, axes = plt.subplots(3, 2, figsize=figsize)    axes[2, 1].remove()    for i, ax in enumerate(axes.flat):        if ps is True:            for j in range(dperc.shape[0]):                ax.fill_between(x, up[j, :, i], lp[j, :, i],                                alpha=alphas[j], color='Blue', label='{}% ci'.format(ci[j]))        if cmedian is not None:            ax.plot(x, ts_median[:, i], color=cmedian, linewidth=0.1, label='Posterior predictive median')        if x_test is not None:            ax.plot(x, x_test[:, i], linestyle='--', color='black')        ax.set_title(labels[i])        ax.legend(loc=1, prop={'size': 7})        if i == 4:            break    plt.tight_layout()    plt.show()