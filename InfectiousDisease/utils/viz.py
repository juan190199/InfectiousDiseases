import numpy as npimport matplotlib.pyplot as pltimport seaborn as snsfrom itertools import combinationsfrom sklearn.metrics import r2_scorefrom data.data_filtering import sanity_checksfrom matplotlib.ticker import FormatStrFormatterdef plot_true_est_scatter(model, X_test, theta_test, n_samples, param_names,                          figsize=(20, 4), theta_approx_means=None, show=True, filename=None, font_size=12):    """    Plots a scatter plot with abline of the estimated posterior means vs true values.    """    # Plot settings    plt.rcParams['font.size'] = font_size    # Convert true parameters to numpy    # theta_test = theta_test.numpy()    # Determine figure layout    if len(param_names) >= 6:        n_col = int(np.ceil(len(param_names) / 2))        n_row = 2    else:        n_col = int(len(param_names))        n_row = 1    # Initialize figure    f, axarr = plt.subplots(n_row, n_col, figsize=figsize)    if n_row > 1:        axarr = axarr.flat    # Initialize posterior means matrix, if none specified    if theta_approx_means is None:        theta_approx_means = model.sample(X_test, n_samples, to_numpy=True).mean(axis=0)    # --- Plot true vs estimated posterior means on a single row --- #    for j in range(len(param_names)):        # Plot analytic vs estimated        axarr[j].scatter(theta_approx_means[:, j], theta_test[:, j], color='black', alpha=0.4)        # get axis limits and set equal x and y limits        lower_lim = min(axarr[j].get_xlim()[0], axarr[j].get_ylim()[0])        upper_lim = max(axarr[j].get_xlim()[1], axarr[j].get_ylim()[1])        axarr[j].set_xlim((lower_lim, upper_lim))        axarr[j].set_ylim((lower_lim, upper_lim))        axarr[j].plot(axarr[j].get_xlim(), axarr[j].get_xlim(), '--', color='black')        # Compute NRMSE        rmse = np.sqrt(np.mean((theta_approx_means[:, j] - theta_test[:, j]) ** 2))        nrmse = rmse / (theta_test[:, j].max() - theta_test[:, j].min())        axarr[j].text(0.1, 0.9, 'NRMSE={:.3f}'.format(nrmse),                      horizontalalignment='left',                      verticalalignment='center',                      transform=axarr[j].transAxes,                      size=10)        # Compute R2        r2 = r2_score(theta_test[:, j], theta_approx_means[:, j])        axarr[j].text(0.1, 0.8, '$R^2$={:.3f}'.format(r2),                      horizontalalignment='left',                      verticalalignment='center',                      transform=axarr[j].transAxes,                      size=10)        # Label plot x-axis        axarr[j].set_xlabel('Estimated')        if j == 0:            # Label plot            axarr[j].set_ylabel('True')        axarr[j].set_title(param_names[j])        axarr[j].spines['right'].set_visible(False)        axarr[j].spines['top'].set_visible(False)    # Adjust spaces    f.tight_layout()    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_scatter.png".format(filename, X_test.shape[1]), dpi=600)def plot_true_est_posterior(model, n_samples, param_names, n_test=None, data_generator=None,                            X_test=None, theta_test=None, figsize=(15, 20), tight=True,                            show=True, filename=None, font_size=12):    """    Plots approximate posteriors.    """    # Plot settings    plt.rcParams['font.size'] = font_size    if data_generator is None and n_test is None:        n_test = int(X_test.shape[0])    # If time series are not provided, then generate the data    elif X_test is None and theta_test is None:        batch = data_generator(batch_size=n_test)        x_test, theta_test = sanity_checks(batch['x'], batch['theta'])        # Reshape x        x_test = x_test.reshape(x_test.shape[0], -1)    else:        raise ValueError('Either data_generator and n_test or X_test and y_test should be provided')    # Convert theta to numpy    # theta_test = theta_test.numpy()    # Initialize f    f, axarr = plt.subplots(n_test, len(param_names), figsize=figsize)    theta_samples = model.sample(X_test, n_samples, to_numpy=True)    theta_samples_means = theta_samples.mean(axis=0)    # For each row    for i in range(n_test):        for j in range(len(param_names)):            # Plot approximate posterior            sns.distplot(theta_samples[:, i, j], kde=True, hist=True, ax=axarr[i, j],                         label='Estimated posterior', color='#5c92e8')            # Plot lines for approximate mean, analytic mean and true data-generating value            axarr[i, j].axvline(theta_samples_means[i, j], color='#5c92e8', label='Estimated mean')            axarr[i, j].axvline(theta_test[i, j], color='#e55e5e', label='True')            axarr[i, j].spines['right'].set_visible(False)            axarr[i, j].spines['top'].set_visible(False)            axarr[i, j].xaxis.set_major_formatter(FormatStrFormatter('%.2f'))            axarr[i, j].get_yaxis().set_ticks([])            # Set title of first row            if i == 0:                axarr[i, j].set_title(param_names[j])            if i == 0 and j == 0:                f.legend(loc='lower center', bbox_to_anchor=(0.5, -0.03), shadow=True, ncol=3, fontsize=10,                         borderaxespad=1)                # axarr[i, j].legend(fontsize=10)    if tight:        f.tight_layout()    f.subplots_adjust(bottom=0.12)    # Show, if specified    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_density.png".format(filename, X_test.shape[1]), dpi=600, bbox_inches='tight')def plot_correlation_parameters(parameters, parameter_names, figsize=(20, 10), show=True, font_size=12):    """    :param parameters:    :param parameter_names:    :param figsize:    :param show:    :param filename:    :param font_size:    :return:    """    # Plot settings    plt.rcParams['font.size'] = font_size    # Get all possible combinations between parameters    comp_list = list(combinations(np.arange(parameters.shape[1]), 2))    # List of comp_params    comp_params = []    comp_param_names = []    for (i, j) in comp_list:        comp_params.append(np.column_stack((parameters[:, i], parameters[:, j])))        comp_param_names.append([parameter_names[i], parameter_names[j]])    # print(comp_params[0].shape)    fig, ax = plt.subplots(2, 5, figsize=figsize)    for idx in range(int(len(comp_list) / 2)):        ax[0, idx].scatter(comp_params[idx][:, 0], comp_params[idx][:, 1], color='black', alpha=0.4)        ax[0, idx].set_xlabel(comp_param_names[idx][0], fontsize=15)        ax[0, idx].set_ylabel(comp_param_names[idx][1], fontsize=15)        ax[1, idx].scatter(comp_params[5 + idx][:, 0], comp_params[5 + idx][:, 1], color='black', alpha=0.4)        ax[1, idx].set_xlabel(comp_param_names[idx + 5][0], fontsize=15)        ax[1, idx].set_ylabel(comp_param_names[idx + 5][1], fontsize=15)    # lower_lim = min(plt.xlim()[0], plt.ylim()[0])    # upper_lim = max(plt.xlim()[1], plt.ylim()[1])    # plt.xlim((lower_lim, upper_lim))    # plt.ylim((lower_lim, upper_lim))    # plt.plot(plt.xlim(), plt.ylim(), '--', color='black')    # Label plot    # plt.xlabel(parameter_names[0])    # plt.ylabel(parameter_names[1])    fig.suptitle('Parameter correlation', fontsize=20)    # Adjust spaces    plt.tight_layout()    if show:        plt.figure(figsize=figsize)        plt.show()def plot_comp_post_prior(model, n_samples, param_names, n_test=None, data_generator=None,                         X_test=None, theta_test=None, figsize=(15, 20), tight=True,                         show=True, filename=None, font_size=12):    """    :param model:    :param n_samples:    :param param_names:    :param n_test:    :param data_generator:    :param X_test:    :param theta_test:    :param figsize:    :param tight:    :param show:    :param filename:    :param font_size:    :return:    """    # Plot settings    plt.rcParams['font.size'] = font_size    if data_generator is None and n_test is None:        n_test = int(X_test.shape[0])    elif X_test is None and theta_test is None:        batch = data_generator(batch_size=n_test)        x_test, theta_test = sanity_checks(batch['x'], batch['theta'])        # Reshape x        x_test = x_test.reshape(x_test.shape[0], -1)    else:        raise ValueError('Either data_generator and n_test or X_test and y_test should be provided')        # Convert theta to numpy    # theta_test = theta_test.numpy()    # Initialize f    f, axarr = plt.subplots(n_test, len(param_names), figsize=figsize)    theta_samples = model.sample(X_test, n_samples, to_numpy=True)    theta_samples_means = theta_samples.mean(axis=0)    # For each row    for i in range(n_test):        for j in range(len(param_names)):            for k in [theta_samples[:, i, j], theta_test[i, j]]:                sns.distplot(k, kde=False, hist=True, ax=axarr[i, j],                             label=['Estimated posterior', 'Prior'])            # Plot prior distribution            # sns.distplot(theta_test[i, j], kde=False, hist=True, ax=axarr[i, j], label='Prior', color='#3d719a')            # Plot approximate posterior            # sns.distplot(theta_samples[:, i, j], kde=False, hist=True, ax=axarr[i, j], label='Estimated posterior',            #              color='#5c92e8')            # Plot lines for approximate mean, analytic mean and true data-generating value            axarr[i, j].axvline(theta_samples_means[i, j], color='#5c92e8', label='Estimated mean')            axarr[i, j].axvline(theta_test[i, j], color='#e55e5e', label='True')            axarr[i, j].spines['right'].set_visible(False)            axarr[i, j].spines['top'].set_visible(False)            axarr[i, j].xaxis.set_major_formatter(FormatStrFormatter('%.2f'))            axarr[i, j].get_yaxis().set_ticks([])            # Set title of first row            if i == 0:                axarr[i, j].set_title(param_names[j])            if i == 0 and j == 0:                f.legend(loc='lower center', bbox_to_anchor=(0.5, -0.03), shadow=True, ncol=3, fontsize=10,                         borderaxespad=1)                # axarr[i, j].legend(fontsize=10)    if tight:        f.tight_layout()    f.subplots_adjust(bottom=0.12)    # Show, if specified    if show:        plt.show()    # Save if specified    if filename is not None:        f.savefig("figures/{}_{}n_density.png".format(filename, X_test.shape[1]), dpi=600, bbox_inches='tight')def plot_ts(x, ts, labels, cmean=None, cmedian=None, ci=None, figsize=(20, 4), font_size=18):    plt.rcParams['font.size'] = font_size    colormap = ci    # Calculate stats    if ci is not None:        ci = [75]        dci = (100 - np.array(ci)) / 2        uperc = 50 + dci        lperc = 50 - dci        up = np.nanpercentile(ts, q=uperc, axis=0)        lp = np.nanpercentile(ts, q=lperc, axis=0)    if cmean is not None:        ts_mean = np.nanmean(ts, axis=0)    if cmedian is not None:        ts_median = np.nanmedian(ts, axis=0)    # Plot    fig, ax = plt.subplots(1, 5, figsize=figsize)    for i in range(5):        if ci is not None:            for j in range(dci.shape[0]):                # ax[i].fill_between(x, up[j, 0, :, i], lp[j, 0, :, i], color=colormap(j / dci.shape[0]))                ax[i].fill_between(x, up[j, 0, :, i], lp[j, 0, :, i], color=colormap)        if cmean is not None:            ax[i].plot(x, ts_mean[0, :, i], color=cmean)        if cmedian is not None:            ax[i].plot(x, ts_median[0, :, i], color=cmedian)    plt.tight_layout()    plt.show()